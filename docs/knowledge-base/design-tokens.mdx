---
id: design-tokens
slug: /knowledge-base/design-tokens
title: "üé® Design Tokens"
sidebar_label: "üé® Design Tokens"
---

import {
  CloudTokenGrid,
  ThemeSplitCloud,
  CloudTokenLineage,
  TokenCalloutCloud,
  AccessibilityContrastCloud,
  TokenUsageCloud,
  FloatInLeft,
  FloatInRight,
  FloatInPlace,
  AnimatedFigureCaption
} from '@site/src/components/KnowledgeBaseComps';

<FloatInPlace>
# üé® Design Tokens
</FloatInPlace>

---

## What Are Tokens?

<FloatInLeft>
Design tokens are the **atomic units of a design system**, similar to how molecules form the building blocks of complex structures. Each token encodes a specific value such as a color, a spacing rule, or a typography size, but it does so in a way that is both semantic and reusable. For example, a raw value like <code>#3F8CFF</code> becomes <code>--color-primary</code>, or a simple <code>16px</code> spacing unit becomes <code>--spacing-md</code>. These abstractions mean that design decisions are not repeated manually; instead they are referenced consistently across the entire system.
</FloatInLeft>

<FloatInLeft>

Rather than scattering hardcoded values throughout components or style sheets, teams define tokens once and apply them everywhere. When you change a base token such as a brand color or a border radius, the update cascades through every component that references it. This approach drives **consistency**, improves iteration speed, and drastically reduces regressions. A single adjustment to a token can improve hundreds of UI elements without requiring hand edits.
</FloatInLeft>


<FloatInLeft>
Think of managing a large library of UI elements as managing a cloud made up of countless droplets. With tokens, each droplet has a clear purpose, a name, and a place within the larger system. Developers no longer wonder which shade of blue is correct or how much padding a card should have. They follow a centralized visual language that reflects shared design intent.
</FloatInLeft>

<FloatInLeft>

Designers benefit just as much. When tokens are linked to Figma libraries or other design tools, every contributor speaks the same language. Tokens become a bridge between design and engineering, connecting intent with implementation and fostering collaboration between product, QA, accessibility teams, and beyond.
</FloatInLeft>


<CloudTokenGrid
  tokens={[
    { name: "--color-primary", type: "Color", value: "#3F8CFF", usage: "Buttons, links" },
    { name: "--spacing-md", type: "Spacing", value: "16px", usage: "Card padding, form spacing" },
    { name: "--radius-card", type: "Radius", value: "12px", usage: "Modal and card borders" },
    { name: "--font-size-lg", type: "Typography", value: "20px", usage: "Large headlines" }
  ]}
/>
<AnimatedFigureCaption>
Figure 1. Foundational tokens displayed in a grid, illustrating their type, value, and practical use throughout the interface.
</AnimatedFigureCaption>

<FloatInLeft>
Tokens are more than variables. They are semantic agreements within your design system. When you define a token, you are declaring a standard and ensuring that the same value is used across multiple platforms and teams. This makes your design system scalable, consistent, and ready for future growth.
</FloatInLeft>

<FloatInLeft>

Next, we will look at how tokens handle theme variations. This includes how the same semantic token can resolve to a light or dark value, enabling entire interfaces to shift modes while maintaining structure and accessibility.
</FloatInLeft>


---

## Light and Dark Token Pairs

<FloatInLeft>
Maintaining visual consistency across light and dark modes is challenging, but semantic tokens solve this elegantly. A single token such as <code>--color-surface</code> can map to a light value like <code>#FFFFFF</code> and a dark value like <code>#1A1A1A</code>. By tying both themes to the same token name, you preserve brand identity, readability, and accessibility without duplicating your design logic.
</FloatInLeft>

<ThemeSplitCloud
  lightLabel="Light Mode"
  darkLabel="Dark Mode"
  tokenName="--color-surface"
  lightValue="#FFFFFF"
  darkValue="#1A1A1A"
/>
<AnimatedFigureCaption>
Figure 2. A semantic surface token configured with theme-specific values, allowing for seamless light and dark mode support.
</AnimatedFigureCaption>

<FloatInLeft>

This separation between definition and rendering gives teams flexibility. Theme adjustments, accessibility fixes, and branding updates can be shipped without rewriting component logic. In practical terms, tokens separate the ‚Äúwhat‚Äù from the ‚Äúhow,‚Äù enabling both robust architecture and strong design governance.
</FloatInLeft>


---

## Token Inheritance and Structure

<FloatInLeft>

Not every token exists in isolation. Many are derived from others, creating a lineage that reduces redundancy. For example, <code>--color-primary-hover</code> might be calculated as a lighter variant of <code>--color-primary</code>. Rather than redefining each variation manually, you establish relationships between tokens, making them easier to maintain and update as brand guidelines evolve.
</FloatInLeft>


<CloudTokenLineage
  root="--color-primary"
  children={["--color-primary-button", "--color-primary-hover", "--color-primary-border"]}
/>
<AnimatedFigureCaption>
Figure 3. A token lineage view showing how related tokens inherit and extend the primary color family.
</AnimatedFigureCaption>

<FloatInLeft>
This structure aligns with sound engineering principles such as ‚Äúdon‚Äôt repeat yourself.‚Äù It also ensures that updates to a base token ripple through dependent tokens without creating inconsistencies. Enterprise-scale systems rely on these hierarchies to apply brand rules across many platforms while maintaining a single source of truth.
</FloatInLeft>

---

## Code-Like Token Usage

<FloatInLeft>
Tokens are not theoretical concepts. They live in code and are implemented in real components. A design token defined as <code>--spacing-md</code> might appear in a CSS file, be imported as a JavaScript constant, or map to a platform-specific variable in a native app. This unified representation ensures that the design language stays consistent across web, iOS, Android, and any other platform.
</FloatInLeft>

<TokenCalloutCloud
  token="--radius-card"
  value="12px"
  alias="--radius-base"
  note="Used consistently for modals, dropdowns, and card corners"
/>
<AnimatedFigureCaption>
Figure 4. A token alias pattern that improves clarity and enforces consistent corner treatments across components.
</AnimatedFigureCaption>

<FloatInLeft>

Maintaining this mapping is critical. When a designer updates the approved border radius, developers should see the same change reflected in code. Tokens ensure that alignment, making design and development partners rather than disconnected silos.
</FloatInLeft>


---

## Accessibility and Contrast

<FloatInLeft>

Accessibility is not an afterthought in token-driven systems. Tokens can store color pairs that already meet WCAG standards, meaning designers and developers work from approved values that ensure legibility and inclusivity by default. Instead of calculating ratios manually or fixing problems late, accessibility is baked in from the start.
</FloatInLeft>


<AccessibilityContrastCloud
  backgroundColor="#1A1A1A"
  textColor="#FFFFFF"
  pass={true}
/>
<AnimatedFigureCaption>
Figure 5. A contrast validation check demonstrates how tokens enforce legible color pairings across themes.
</AnimatedFigureCaption>

<FloatInLeft>
Encoding accessibility into token logic gives teams confidence. Designers can explore freely, developers can build quickly, and QA teams can validate without starting from scratch. The system itself enforces compliance at every layer.
</FloatInLeft>

---

## Where Tokens Live and Breathe

<FloatInLeft>
Tokens appear in every part of an interface. Buttons, modals, input fields, alerts, and empty states all rely on them for spacing, color, typography, shadows, and even animation curves. A single update to a well-managed token can bring consistency to hundreds of components in one step.
</FloatInLeft>

<TokenUsageCloud
  token="--spacing-md"
  usedIn={["Card", "FormField", "Modal", "ListItem"]}
/>
<AnimatedFigureCaption>
Figure 6. A spacing token shown in use across multiple components to maintain rhythm and alignment.
</AnimatedFigureCaption>

<FloatInLeft>

Tokens are most effective when actively maintained. Review them periodically, retire duplicates, and refactor overlapping values. A living token system is what enables your design language to evolve without chaos.
</FloatInLeft>


---

## Recap and What‚Äôs Next

<FloatInLeft>
Design tokens form the backbone of a scalable design system. They abstract raw values into meaningful variables that bridge visual intent and implementation. By defining and documenting them carefully, teams gain a shared language that improves speed, reduces friction, and protects brand integrity.
</FloatInLeft>

<FloatInLeft>

Tokens also unlock adaptability. Brand changes, new accessibility standards, or theme updates can be implemented swiftly and with confidence. Much like musical notation guides an orchestra, tokens guide designers and developers to work in harmony and keep the system cohesive.
</FloatInLeft>


<FloatInLeft>
This token-driven approach supports onboarding, cross-platform alignment, and long-term stability. Whether you build for web, mobile, or emerging platforms, tokens provide a reliable foundation that evolves alongside your product.
</FloatInLeft>

<FloatInLeft>

In the next section, you will see how these atomic values scale into modular components. Components are built from tokens, and together they form the patterns, behaviors, and user experiences that define your product. Let‚Äôs move forward and see how these foundational rules take shape in the structures you ship.
</FloatInLeft>

